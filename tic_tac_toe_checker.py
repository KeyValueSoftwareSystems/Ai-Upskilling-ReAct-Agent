"""
tic_tac_toe_checker.py - Custom ToTChecker for Tic-Tac-Toe

This file contains:
- Custom ToTChecker implementation for tic-tac-toe game
- Move validation and game state evaluation
- Integration with LangChain Experimental ToT framework
"""

import re
from typing import Tuple
from langchain_experimental.tot.checker import ToTChecker
from langchain_experimental.tot.thought import ThoughtValidity

# Note: We don't need to import TicTacToeGame or GameStatus for this checker


class TicTacToeToTChecker(ToTChecker):
    """
    Custom ToTChecker for tic-tac-toe game.

    This checker evaluates whether the thoughts generated by the ToT agent
    lead to valid moves and good strategic decisions in tic-tac-toe.
    """

    def evaluate(
        self,
        problem_description: str,
        thoughts: Tuple[str, ...] = (),
    ) -> ThoughtValidity:
        """
        Evaluate the thoughts for tic-tac-toe game validity.

        Args:
            problem_description: String description of the current game state
            thoughts: Tuple of thought strings generated by the agent

        Returns:
            ThoughtValidity indicating the quality of the thoughts
        """
        try:
            # Parse the current game state from problem description
            game_state = self._parse_game_state(problem_description)
            if not game_state:
                return ThoughtValidity.INVALID

            # If no thoughts provided, consider it invalid
            if not thoughts:
                return ThoughtValidity.INVALID

            # Evaluate each thought
            valid_moves = 0
            strategic_quality = 0

            for thought in thoughts:
                # Extract move from thought
                move = self._extract_move_from_thought(thought)
                if move is None:
                    continue

                # Check if move is valid
                if self._is_valid_move(game_state, move):
                    valid_moves += 1

                    # Check strategic quality
                    if self._evaluate_strategic_quality(game_state, move, thought):
                        strategic_quality += 1

            # Determine validity based on results
            if valid_moves == 0:
                return ThoughtValidity.INVALID
            elif (
                valid_moves == len(thoughts)
                and strategic_quality >= len(thoughts) * 0.5
            ):
                # All moves are valid and at least half show good strategy
                return ThoughtValidity.VALID_FINAL
            elif valid_moves >= len(thoughts) * 0.7:
                # Most moves are valid
                return ThoughtValidity.VALID_INTERMEDIATE
            else:
                return ThoughtValidity.INVALID

        except (ValueError, KeyError, AttributeError, IndexError):
            # If any error occurs during evaluation, consider invalid
            return ThoughtValidity.INVALID

    def _parse_game_state(self, problem_description: str) -> dict:
        """Parse the game state from the problem description."""
        try:
            # Extract board state from the description
            board = [""] * 9

            # Look for board representation in the description
            lines = problem_description.split("\n")
            board_lines = []

            for line in lines:
                if "|" in line and ("X" in line or "O" in line or " " in line):
                    board_lines.append(line)

            if len(board_lines) >= 3:
                # Parse the 3x3 board
                for i, line in enumerate(board_lines[:3]):
                    cells = [cell.strip() for cell in line.split("|")]
                    for j, cell in enumerate(cells[:3]):
                        if cell in ["X", "O"]:
                            board[i * 3 + j] = cell

            # Extract current player
            current_player = "O"  # Default
            for line in lines:
                if "Current Player:" in line:
                    player_match = re.search(r"Current Player:\s*([XO])", line)
                    if player_match:
                        current_player = player_match.group(1)
                    break

            return {"board": board, "current_player": current_player}

        except (ValueError, KeyError, AttributeError, IndexError):
            return None

    def _extract_move_from_thought(self, thought: str) -> int:
        """Extract move position from a thought string."""
        try:
            # Coordinate mapping: A1-C3 to 0-8 indices
            coord_to_index = {
                "A1": 0,
                "A2": 1,
                "A3": 2,
                "B1": 3,
                "B2": 4,
                "B3": 5,
                "C1": 6,
                "C2": 7,
                "C3": 8,
            }

            # Look for A1-C3 coordinates first (new system)
            coord_patterns = [
                r"place\s+[oO]\s+(?:at\s+)?([A-C][1-3])",
                r"move\s+[oO]\s+to\s+([A-C][1-3])",
                r"([A-C][1-3])\s+is\s+the\s+best",
                r"choose\s+([A-C][1-3])",
                r"select\s+([A-C][1-3])",
                r"play\s+in\s+([A-C][1-3])",
                r"center.*?([A-C][1-3])",
                r"best\s+move\s+is.*?([A-C][1-3])",
                r"will\s+play.*?([A-C][1-3])",
                r"final\s+move.*?([A-C][1-3])",
                r"decision.*?([A-C][1-3])",
                r"conclusion.*?([A-C][1-3])",
                r"strategic.*?([A-C][1-3])",
            ]

            for pattern in coord_patterns:
                match = re.search(pattern, thought.upper())
                if match:
                    coord = match.group(1)
                    if coord in coord_to_index:
                        return coord_to_index[coord]

            # Look for standalone coordinates
            coord_matches = re.findall(r"\b([A-C][1-3])\b", thought.upper())
            if coord_matches:
                last_coord = coord_matches[-1]
                if last_coord in coord_to_index:
                    return coord_to_index[last_coord]

            # Fallback: look for any coordinate pattern
            coord_match = re.search(r"([A-C][1-3])", thought.upper())
            if coord_match:
                coord = coord_match.group(1)
                if coord in coord_to_index:
                    return coord_to_index[coord]

            # Legacy fallback: look for numbers 0-8 in the thought
            numbers = re.findall(r"\b([0-8])\b", thought)
            if numbers:
                return int(numbers[-1])  # Take the last number found

            # Look for position references
            if "position" in thought.lower():
                pos_match = re.search(r"position\s+([0-8])", thought.lower())
                if pos_match:
                    return int(pos_match.group(1))

            # Look for corner references
            corner_map = {
                "top-left": 0,
                "top-right": 2,
                "bottom-left": 6,
                "bottom-right": 8,
                "center": 4,
                "middle-left": 3,
                "middle-right": 5,
                "top-center": 1,
                "bottom-center": 7,
            }

            for corner, pos in corner_map.items():
                if corner in thought.lower():
                    return pos

            return None

        except (ValueError, KeyError, AttributeError, IndexError):
            return None

    def _is_valid_move(self, game_state: dict, move: int) -> bool:
        """Check if a move is valid for the current game state."""
        try:
            board = game_state.get("board", [""] * 9)
            return 0 <= move <= 8 and move < len(board) and board[move] == ""
        except (ValueError, KeyError, AttributeError, IndexError):
            return False

    def _evaluate_strategic_quality(
        self, game_state: dict, move: int, thought: str
    ) -> bool:
        """Evaluate the strategic quality of a move and its reasoning."""
        try:
            board = game_state.get("board", [""] * 9)
            current_player = game_state.get("current_player", "O")

            # Check for strategic keywords in the thought
            strategic_keywords = [
                "win",
                "block",
                "center",
                "corner",
                "defensive",
                "offensive",
                "strategy",
                "threat",
                "opportunity",
                "prevent",
                "create",
            ]

            thought_lower = thought.lower()
            has_strategic_keywords = any(
                keyword in thought_lower for keyword in strategic_keywords
            )

            # Check if move is strategically sound
            is_strategic = self._is_strategic_move(board, move, current_player)

            # Consider it good quality if it has strategic keywords or is strategically sound
            return has_strategic_keywords or is_strategic

        except (ValueError, KeyError, AttributeError, IndexError):
            return False

    def _is_strategic_move(self, board: list, move: int, player: str) -> bool:
        """Check if a move is strategically sound."""
        try:
            # Center is always strategic
            if move == 4:
                return True

            # Corners are strategic
            if move in [0, 2, 6, 8]:
                return True

            # Check if move creates a winning opportunity
            if self._creates_winning_opportunity(board, move, player):
                return True

            # Check if move blocks opponent's winning opportunity
            opponent = "X" if player == "O" else "O"
            if self._blocks_opponent_win(board, move, opponent):
                return True

            return False

        except (ValueError, KeyError, AttributeError, IndexError):
            return False

    def _creates_winning_opportunity(self, board: list, move: int, player: str) -> bool:
        """Check if a move creates a winning opportunity."""
        try:
            # Temporarily place the move
            temp_board = board.copy()
            temp_board[move] = player

            # Check all winning conditions
            win_conditions = [
                [0, 1, 2],
                [3, 4, 5],
                [6, 7, 8],  # Rows
                [0, 3, 6],
                [1, 4, 7],
                [2, 5, 8],  # Columns
                [0, 4, 8],
                [2, 4, 6],  # Diagonals
            ]

            for condition in win_conditions:
                if move in condition:
                    count = sum(1 for pos in condition if temp_board[pos] == player)
                    if count >= 2:  # Two in a row, third would win
                        return True

            return False

        except (ValueError, KeyError, AttributeError, IndexError):
            return False

    def _blocks_opponent_win(self, board: list, move: int, opponent: str) -> bool:
        """Check if a move blocks opponent's winning opportunity."""
        try:
            # Temporarily place the move
            temp_board = board.copy()
            temp_board[move] = "X"  # Place our piece to block

            # Check all winning conditions for opponent
            win_conditions = [
                [0, 1, 2],
                [3, 4, 5],
                [6, 7, 8],  # Rows
                [0, 3, 6],
                [1, 4, 7],
                [2, 5, 8],  # Columns
                [0, 4, 8],
                [2, 4, 6],  # Diagonals
            ]

            for condition in win_conditions:
                if move in condition:
                    opponent_count = sum(
                        1 for pos in condition if temp_board[pos] == opponent
                    )
                    if opponent_count >= 2:  # Opponent had two in a row, we're blocking
                        return True

            return False

        except (ValueError, KeyError, AttributeError, IndexError):
            return False
